#+OPTIONS: toc:nil num:nil todo:nil pri:nil tags:nil 

#+OPTIONS: ^:nil 
#+OPTIONS: tex:t

#+TITLE: Implementing the Levenberg-Marquardt method

* Problem description

This is a *nonlinear least squares* problem

\[ \theta = \arg \min \limits_\theta \frac{1}{2}\|f(\theta)\|^2 \]

where $f\in\mathbb{R}^m\rightarrow \mathbb{R}^n$ with $m$ the
dimension of our unknown vector $\theta$ and $n$ the number of
sample point $(X_i,Y_i)$. $\|.\|$ is the euclidean norm.

If we explicitly write $(X_i,Y_i)$, the objective fonction can be
written in a _equivalent_ but more familiar way:

\[ \theta = \arg \min \limits_\theta \frac{1}{2}\sum\limits_{i=1}^m \|Y_i-f_i(\theta;X_i)\|^2_2 \]

** Gradient and Hessian computation

Our notation for the differential evaluated at $\theta$ is
$df_\theta\in\mathcal{L}(\mathbb{R}^m,\mathbb{R}^n)$. Its action on a
vector $h$ is noted $df_\theta . h \in \mathbb{R}^n$

We use the more synthetic definition $F(\theta)=\frac{1}{2}\|f(\theta)\|^2_2$, the chain rule gives:

\[
dF_\theta.h = \frac{1}{2} d_{f(\theta)}(. \rightarrow \|.\|^2)\circ df_\theta.h = \langle f(\theta),df_\theta.h \rangle 
\]

\[ d^2F_\theta(h,k) = \langle df(\theta).h,df(\theta).k \rangle +
\underbrace{\langle f(\theta),d^2f(\theta).(h,k)
\rangle}_{\text{négligé car }f\simeq 0} \]

* Mathetamica test

** Preamble

*** Gradient computation can be done as follow

# Note: if we choose #+BEGIN_SRC mathematica, :exports code still export a null result
#       which is problematic when export as HTML or PDF
# 
#+NAME: mathematica_grad
#+BEGIN_SRC text
grad[f_, var_List] := D[f, #] & /@ var;
#+END_SRC

*** Function to fit

#+NAME: mathematica_toFit
#+BEGIN_SRC text
(* Function to fit  *)
f[x_]:=a0+a1*x+a2*x*x;

(* Parameters  *)
theta={a0,a1,a2};

(* Parameter value *)
thetaTrueValue={1,2,-1};
#+END_SRC

*** Data
#+NAME: mathematica_data
#+BEGIN_SRC text
nSample = 10;
xSample = Table[i/nSample,{i,0,nSample-1}];
ySample = Table[f[xSample[[i]]]  /. Thread[theta ->thetaTrueValue],{i,1,nSample}];
#+END_SRC


#+BEGIN_SRC mathematica :exports both :noweb yes
<<mathematica_grad>>
<<mathematica_toFit>>
<<mathematica_data>>

\[Theta] = ySample
#+END_SRC

#+RESULTS:
| 1 | 119/100 | 34/25 | 151/100 | 41/25 | 7/4 | 46/25 | 191/100 | 49/25 | 199/100 |


#+BEGIN_SRC mathematica :exports both 
(* Gradient Computation *)
grad[f_, var_List] := D[f, #] & /@ var;

(* Function to fit *)
f[x_] := a0 + a1*x + a2*x*x;

(* Parameters *)
theta = {a0, a1, a2};

(* Generate data to fit from theta true value *)

thetaTrueValue = {1, 2, -1};
nSample = 10;
xSample = Table[i/nSample, {i, 0, nSample - 1}];
ySample = 
  Table[f[xSample[[i]]] /. Thread[theta -> thetaTrueValue], {i, 1, 
    nSample}];

(* Define objective function *)

evalObjectiveGradHessian[f_] := 
  Module[{F, dF}, 
   F = Table[ySample[[i]] - f[xSample[[i]]], {i, 1, nSample}]; 
   dF = grad[F, theta]; Return[{F.F/2, dF.F, dF.Transpose[dF]}]];

evalObjectiveGradHessian[f] 
#+END_SRC

#+RESULTS:
| ((1 - a0) ^2 + (199/100 - a0 - (9*a1) /10 - (81*a2) /100) ^2 + (49/25 - a0 - (4*a1) /5 - (16*a2) /25) ^2 + (191/100 - a0 - (7*a1) /10 - (49*a2) /100) ^2 + (46/25 - a0 - (3*a1) /5 - (9*a2) /25) ^2 + (7/4 - a0 - a1/2 - a2/4) ^2 + (41/25 - a0 - (2*a1) /5 - (4*a2) /25) ^2 + (151/100 - a0 - (3*a1) /10 - (9*a2) /100) ^2 + (34/25 - a0 - a1/5 - a2/25) ^2 + (119/100 - a0 - a1/10 - a2/100) ^2) | /2 | (-323/20 + 10*a0 + (9*a1) /2 + (57*a2) /20 (-9* (199/100 - a0 - (9*a1) /10 - (81*a2) /100)) /10 - (4* (49/25 - a0 - (4*a1) /5 - (16*a2) /25)) /5 - (7* (191/100 - a0 - (7*a1) /10 - (49*a2) /100)) /10 - (3* (46/25 - a0 - (3*a1) /5 - (9*a2) /25)) /5 - (2* (41/25 - a0 - (2*a1) /5 - (4*a2) /25)) /5 - (3* (151/100 - a0 - (3*a1) /10 - (9*a2) /100)) /10 + (-119/100 + a0 + a1/10 + a2/100) /10 + (-34/25 + a0 + a1/5 + a2/25) /5 + (-7/4 + a0 + a1/2 + a2/4) /2 (-81* (199/100 - a0 - (9*a1) /10 - (81*a2) /100)) /100 - (16* (49/25 - a0 - (4*a1) /5 - (16*a2) /25)) /25 - (49* (191/100 - a0 - (7*a1) /10 - (49*a2) /100)) /100 - (9* (46/25 - a0 - (3*a1) /5 - (9*a2) /25)) /25 - (4* (41/25 - a0 - (2*a1) /5 - (4*a2) /25)) /25 - (9* (151/100 - a0 - (3*a1) /10 - (9*a2) /100)) /100 + (-119/100 + a0 + a1/10 + a2/100) /100 + (-34/25 + a0 + a1/5 + a2/25) /25 + (-7/4 + a0 + a1/2 + a2/4) /4) | ((10 9/2 57/20) (9/2 57/20 81/40) (57/20 81/40 15333/10000)) |



