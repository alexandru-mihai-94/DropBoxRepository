#+DATE: [2016-06-27 Mon 10:32]
#+OPTIONS: toc:nil num:nil todo:nil pri:nil tags:nil ^:nil tex:t  
#+CATEGORY: C++,Julia,Computations
#+TAGS:
#+DESCRIPTION:
#+TITLE: A remark about min()/max() functions

Computing the *min* (or *max*) of two values looks like a trivial
task.

For *C++* the default Standard Template Library (STL) implementation
is

#+BEGIN_SRC C++ :exports code
inline const _Tp& min(const _Tp& __a, const _Tp& __b)
{
	return __b < __a ? __b : __a;
}
#+END_SRC

However for numerical computations this definition does not mix well
with the [[https://en.wikipedia.org/wiki/IEEE_floating_point][IEEE 754]] standard when dealing with potential *NaN* value.

For instance, *min()* is _not commutative_ and is _not equivatent_ to
*cmath::fmin()*, we have:

#+BEGIN_SRC C++ :main no :flags -std=c++11 :results org :exports both
#include <iostream>
#include <cmath>
#include <limits>
#include <cassert>

using namespace std;

int main()
{
    const auto x_nan = numeric_limits<double>::quiet_NaN();
    const auto x_1 = 1.;

	cout << boolalpha;

    cout << "\n\ncommutativity?";
    cout << "\n min: " << (min(x_1, x_nan) == min(x_nan, x_1));
    cout << "\nfmin: " << (fmin(x_1, x_nan) == fmin(x_nan, x_1));
}
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
commutativity?
 min: false
fmin: true
#+END_SRC

The [[https://en.wikipedia.org/wiki/NaN][IEEE 754]] says:
#+BEGIN_QUOTE
In section 6.2 of the revised IEEE 754-2008 standard there are two
anomalous functions (the maxnum and minnum functions that return the
maximum of two operands that are expected to be numbers) that favor
numbers â€” if just one of the operands is a NaN then the value of the
other operand is returned.
#+END_QUOTE

On the opposite you can read about C++ rules [[http://www.drdobbs.com/cpp/its-hard-to-compare-floating-point-numbe/240149806][here]]:
#+BEGIN_QUOTE
NaN values have the curious property that they compare as "unordered"
with all values, even with themselves. In other words, if x is a NaN,
and y is any floating-point value, NaN or not, then x<y, x>y, x<=y,
x>=y, and x==y are all false, and x!=y is true.
#+END_QUOTE


Min() or max()
#+BEGIN_SRC C++ :includes <iostream> :flags -std=c++11
std::cout << "\nToto";
#+END_SRC

#+RESULTS:
: Toto

#+BEGIN_SRC julia 
5+7
#+END_SRC

#+RESULTS:
: 12


#+NAME: example-table
          | 1 | 4 |
          | 2 | 4 |
          | 3 | 6 |
          | 4 | 8 |
          | 7 | 0 |

#+BEGIN_SRC mathematica :var x=example-table :exports both :results latex
D[y*y^10+1,y] // TeXForm
#+END_SRC

#+RESULTS:
#+BEGIN_LaTeX
11 y^{10}
#+END_LaTeX

#+BEGIN_SRC latex :exports results 
\LaTeX
#+END_SRC

#+RESULTS:
#+BEGIN_LaTeX
\LaTeX
#+END_LaTeX


#+tblname: data-table
| x | y1 | y2 |
|---+----+----|
| 0 |  3 |  6 |
| 1 |  4 |  7 |
| 2 |  5 |  8 |



#+begin_src gnuplot :exports code :file file.png
reset

set title "Putting it All Together"
plot x,y
#+end_src

#+RESULTS:
[[file:file.png]]



