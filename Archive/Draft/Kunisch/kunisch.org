#+BLOG: wordpress
#+POSTID: 297
#+DATE: [2016-07-03 Sun 07:43]
#+OPTIONS: toc:nil num:nil todo:nil pri:nil tags:nil 

#+OPTIONS: ^:nil 
#+OPTIONS: tex:t


#+LaTeX_HEADER: \usepackage[ruled,vlined,algonl]{algorithm2e} 
#+LaTeX_HEADER: \usepackage{amsthm}
#+LaTeX_HEADER: \usepackage{amsmath}      
#+LaTeX_HEADER: \usepackage{amsfonts}           
#+LaTeX_HEADER: \usepackage{amssymb}
#+LaTeX_HEADER: \usepackage{listings}
#+LaTeX_HEADER: \usepackage{graphicx} 
#+LaTeX_HEADER: \usepackage{color}
#+LaTeX_HEADER: \usepackage{inconsolata}

#+LaTeX_HEADER: \lstset{basicstyle=\scriptsize\tiny}

# ################################################################

#+TITLE: A simple bound constrained quadratic optimizer in Julia

* Problem description

The goal is to minimize a bound constrained quadratic form where $Q$ is a *symmetric definite positive* matrix.
\begin{equation}
\min\limits_{a\le x \le b} \frac{1}{2} x^t.Q.x + q^t.x
\end{equation}

For well conditionned problems the [[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.8006][Kunisch]] method is a quite effective
method which is also intuitive and easy to implement.

The idea of the method is to guess active constraints, computes the
associated solution with its *a posteriori multipliers*. Then we check
the validity of our initial guess and we make the necessary
corrections and we restart with this new guess. It can be shown, in
exact arithmetic, that this process ends in a finite number of
iterations.

To do this we need to write the Lagragian associated to problem

\begin{equation}
\mathcal{L} = \frac{1}{2} x^t.Q.x + q^t.x + \lambda^t (a-x) + \mu^t (x-b)
\end{equation}

and its gradient

\begin{equation}
\nabla_x \mathcal{L} = Q.x + q -\lambda + \mu = Q.x+q+\tau = 0
\end{equation}
with $\tau =  -\lambda + \mu$ storing multipliers associated to the constraints $x\in[a,b]$

The KKT conditions are
\begin{equation}
\nabla_x \mathcal{L} = Q.x+q-\lambda+\mu =0
\end{equation}
\begin{equation}
(\lambda \ge 0)\wedge(\lambda\odot(a-x))=0 
\end{equation}
\begin{equation}
(\mu \ge 0)\wedge(\mu\odot(x-b))=0
\end{equation}

We introduce a $Z\in\{-1,0,1\}^n$ vector to encode our guess on which contraints are active or not:

\begin{equation}
Z_i = \left\{
\begin{array}{c|c|cc}
-1 & x_i=a_i & \lambda_i = -\tau_i &  \mu_i = 0 \\
0  & a_i \le x_i \le b_i & \lambda_i = 0 & \mu_i = 0 \\
+1 &  x_i=b_i & \lambda_i = 0 &  \mu_i = \tau_i \\
\end{array}
\right.
\end{equation} 

The algorithm takes the following form:

#+BEGIN_SRC latex :exports results :file algo.png :results graphics
\begin{algorithm}[H]
\caption{Kunisch method}
  \KwData{\\
    $Z^{(0)}\in\{-1,01\}^n$ initial guess\\
    $x^{(0)}$ initial guess
  }
  \KwResult{\\
    $x^{(k)}$ and $\tau^{(k)}$ solution of the problem
  }
  \Repeat{$Z^{(k)}\neq Z^{(k+1)}$}{
    \tcp{step 1: Modifies $Q$ and $q$ such that $\tilde{x}^{(k)}$ fulfills active constraints}
    $$
      \tilde{x}^{(k)}= \arg\min\limits_{x}\frac{1}{2} x^t.Q.x + q^t.x
      $$
    $$
    \begin{array}{lll}
      x_i=a_i & \text{if} & Z_i=-1 \\ 
      x_i=b_i & \text{if} & Z_i=+1
    \end{array}
    $$

    \tcp{step 2: compute Multiplicateurs a posteriori:}
    $$
    \tau^{(k)} = -( Q.\tilde{x}^{(k)}+q )
    $$

    \tcp{step 3: Update $Z$ (corrections -> our new guess)}
    $$
    \begin{array}{lrc}
      
      \text{If\ }Z_i^{(k)}=-1 & \text{then} & Z_i^{(k+1)}=
      \left\{
      \begin{array}{rl}
        -1 & \text{if\ }\tau_i\le 0 \\
        0 & \text{otherwise}
      \end{array}
      \right.  \\

      \text{If\ }Z_i^{(k)}=0 & \text{then} & Z_i^{(k+1)}=
      \left\{
      \begin{array}{rl}
        -1 & \text{if\ }x_i<a_i \\
        0 & \text{if\ }a_i\le x_i  \le b_i \\
        +1 & \text{if\ }b_i<x_i
      \end{array}
      \right.  \\

      \text{If\ }Z_i^{(k)}=+1 & \text{then} & Z_i^{(k+1)}=
      \left\{
      \begin{array}{rl}
        1 & \text{if\ }\tau_i\ge 0 \\
        0 & \text{otherwise}
      \end{array}
      \right.  \\
      
    \end{array}
    $$
  }
\end{algorithm}
#+END_SRC

#+RESULTS:
#+BEGIN_LaTeX
[[file:algo.png]]
#+END_LaTeX


[[file:algo.png]]

* Code

Here I provide a direct implementation in Julia of the previous algorithm

** Step 1 implementation

#+BEGIN_SRC latex :exports results :file tt.png :results graphics
\begin{verbatim}
const active_lb = -1::Int
const inactive = 0::Int
const active_ub = +1::Int

function restrict2Active!{T<:BlasFloat,S<:StridedMatrix}(Q::Symmetric{T,S},
                                                         q::StridedVector{T},
                                                         Z::Vector{Int},
                                                         lb::StridedVector{T},
                                                         ub::StridedVector{T})
\end{verbatim}
#+END_SRC

#+RESULTS:
#+BEGIN_LaTeX
[[file:tt.png]]
#+END_LaTeX

[[file:tt.png]]





#+NAME: Step_1
#+BEGIN_SRC julia 
const active_lb = -1::Int
const inactive = 0::Int
const active_ub = +1::Int

function restrict2Active!{T<:BlasFloat,S<:StridedMatrix}(Q::Symmetric{T,S},
                                                         q::StridedVector{T},
                                                         Z::Vector{Int},
                                                         lb::StridedVector{T},
                                                         ub::StridedVector{T})
    
    const n = length(q)
    
    @assert (Q.uplo=='L')||(Q.uplo=='U') "Q.uplo==$(Q.uplo)"
    
    if Q.uplo=='L'

        for k = 1:n
            
            if Z[k]!=inactive

                const constrained_x_k = ifelse(Z[k]==active_lb,
                                               lb[k],
                                               ub[k])

                
                q[1:k-1] += constrained_x_k*Q.data[k,1:k-1]'
                Q.data[k,1:k-1]=zero(T)

                Q_kk = max(1,abs(Q.data[k,k]))
                q[k] = -constrained_x_k*Q_kk
                Q.data[k,k] = Q_kk
                
                q[k+1:n] += constrained_x_k*Q.data[k+1:n,k]
                Q.data[k+1:n,k]=zero(T)
                
            end # Z[k]!=inactive
        end # k = 1:n

    else         
        @assert (Q.uplo=='U') ""
        
        for k = 1:n
            
            if Z[k]!=inactive

                const constrained_x_k = ifelse(Z[k]==active_lb,
                                               lb[k],
                                               ub[k])

                
                q[1:k-1] += constrained_x_k*Q.data[1:k-1,k]
                Q.data[1:k-1,k]=zero(T)

                Q_kk = max(1,abs(Q.data[k,k]))
                q[k] = -constrained_x_k*Q_kk
                Q.data[k,k] = Q_kk
                
                q[k+1:n] += constrained_x_k*Q.data[k,k+1:n]'
                Q.data[k,k+1:n]=zero(T)

            end # Z[k]!=inactive
        end # k = 1:n
        
    end
    
end
#+END_SRC


#+BEGIN_SRC julia 
workspace()
include("./kunisch.jl")
using Kunisch

T=Float64

n=25::Int

lb=Array{T}(n)
lb[:]=0
#lb[3]=convert(T,-Inf)

ub=Array{T}(n)
ub[:]=10

H=T[1/(i+j-1) for i in 1:n,j in 1:n]
# H+=0.1*eye(n)

Q=Symmetric(H,:L)
q=Array{T}(n)
q[:]=-1

# lb=T[0, 0, 0]
# ub=T[10, 20, 30]
# Q=Symmetric(T[30 20 15;20 15 12;15 12 10],:L)
# q=T[-1, -2, -3]

kunisch(Q,q,lb,ub)
#+END_SRC

* Readings 

[[http://philipphungerlaender.jimdo.com/qp-code/][mKR: A Code for Convex Quadratic Programs with Box-Constraints]]

#+name: kunisch
[[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.8006][An Infeasible Active Set Method for Convex Problems With Simple Bounds]]


# algo.png http://pixorblog.files.wordpress.com/2016/07/algo-5.png

# tt.png http://pixorblog.files.wordpress.com/2016/07/tt.png
